2024.10.2

<되돌아보기> 

접근제어자
정의: 멤버변수의 메소드 접근 권한
종류: default, public, private
사용한 예: DTO 성격 (멤버변수 - private - getter와 setter)
-------------------------------------------------------------------------

<Source>
Java는 컴파일 언어이다.

IDE(이클립스)에서 src와 bin의 정의

원시 프로그램
- 사람이 작성한 소스 (src에 직접 작성한, 확장자가 java인 소스) = src

목적 프로그램 
- 기계가 이해, 기계어 번역(컴파일) = 0과 1 조합 (확장자가 class인 소스) = bin
- 컴퓨터에 실행한다는 목적이 있다. 

ctrl+f11: 컴파일 후 프로그램을 실행하는 키 = JRE
		  원시 프로그램을 목적 프로그램으로 바꾼 후 실행한다.
		  ctrl+f11에는 컴파일과 thread가 포함되어 있다.

*** 개발 소스를 배포하지 않고 배포하려면 실행 파일인 bin 파일을 배포하면 된다. (실행만 가능하게끔 한다.)
	개발한 소스는 공개하지 않는다.

<번외>
언어의 종류는 컴파일 언어와 인터프리터가 있다.
Java와 C는 컴파일 언어, JavaScript는 인터프리터이다.
인터프리터는 바로 번역하고 실행한다.
인터프리터가 개발 환경에 적응이 빠르다. 유동적이다.
왜냐하면 컴파일 언어는 수정하면 다시 컴파일 해줘야하기때문이다.
속도는 컴파일 언어가 더 빠르다.

목적 프로그램은 실행중이라고 할 수 있을까?
: No. 원시 프로그램을 번역해놓은 프로그램이다.
  bin은 삭제해도 컴파일하면 다시 생긴다. 
  bin 파일을 메모장에 옮기면 인간이 알아들을 수 없는 언어가 나온다. 
  말 그대로 언어를 읽어내지 못한다는 뜻이며
  프로그램 내의 범용할 수 있는 언어로 최대한 해석한 것이라는 것을 알 수 있다.

<실행 = runtime>  
목적 프로그램을 실행한 것
주기억장치(memory = ram)에 상주해야 실행되고 있는 것
CPU(중앙처리장치)와 RAM(메모리)에서 자원을 사용
CPU : 명령어 (연산자, 메서드 처리 등등)
RAM : 변수
 
Java
- JDK (java development key) : ex) Scanner, ArrayList
- JRE (java run time): 목적 프로그램을 실행시키기 위한 것

<Run Time>: JVM
Thread : 목적 프로그램을 실제 실행하는 기능 = 코드 실행 (한 가지 일만 할 수 있음)
		 여러개의 일을 하려면 멀티로 여러개의 thread를 사용해야한다. 
		 프로그램은 큰 의미이고, thread는 일을 처리하는 것
		 코드를 로딩해서 cpu와 작업을 하고 값들을 메모리에 저장하는 주요 역할을 가지고 있다.
		 Main Method를 제일 먼저 처리한다. *메인을 시작 프로그램이라고 하는 이유
		 
ex) main.class / mge.class / member.class
원시 프로그램은 세개이다.
하드디스크에 저장되어 있다. 
이 세개의 클래스는 하나의 프로그램이다.
여기에서 필요한 코드만 클래스 로드를 한다. 

클래스 로드 -> 소스 코드를 JVM으로 가져옴

JVM의 구조
- Method : 소스 파일, 멤버변수, static(공용 변수) 저장

* static(공용 변수)
객체를 만들지 않아도 접근이 가능하다.
공통적으로 쓸건데 숨길 필요가 없는 경우에 사용 (ex) 회사명, 은행 이자율)
객체는 공용으로 공유하지 않음. 
저장된 메모리를 같이 쓴다.

final (상수)
초기값이 설정된 이후에는 바꿀 수 없다.
상수는 초기값이 결정되면 값을 변경할 수 없다.

- stack : 메서드 call 
		  FILO (First In Last Out)
		  지역 변수 저장
		  
- heap : 객체(인스턴스)
		 생성, 사용, 소멸
		 		 
* 메모리 누수: 사용하지 않는 객체는 메모리를 차지하고 있기만 하다..
			그럼 그만큼의 메모리는 낭비가 되는 것이고 이를 메모리 누수라고 한다.
			Java에는  GC가 있어서 사용하지 않는 객체는 삭제해준다. 
			
* thread는 method와 heap영역을 둘 다 사용한다. 

* 접근제어자, static, final는 각각 독립적인 존재
결과적으로 비슷한 역할을 할 수 있지만 태생과 과정은 다르다.

ex) 만약 공동 작업을 하고 싶은데 새로운 객체를 생성 못하게 하면서 참조하게끔 하려면?
생성자에 private를 사용한다. 그러면 객체를 생성할 수 없게 된다. 
그리고 클래스를 참조하게끔 하려면 public static으로 설정해주면 된다.
예시: a라는 메인 클래스에 생성자에 private를 사용
	 b나 c는 공동 작업자. 이는 각각의 클래스에 객체를 사용할 수 있음. 
	 b와 c의 클래스를 a가 참조하게끔 만들기 위해 public static을 사용
	 모든 곳에서 사용할 수 있으며 공통 언어를 따르겠다는 말임.
